@using LoxSmoke.DocXml
@using System.Reflection
@using System.Text
@using System.Web
@using Ignis.Website.Services
@inherits IgnisAsyncComponentBase
@implements IHandleAfterRender
@* ReSharper disable once InconsistentNaming *@
@inject IJSRuntime JSRuntime
@inject IStringLocalizer<ClassDocumentation> Resources
@inject IStaticFileService StaticFileService

<h2>
    @Type.SanitizeTypeName()
</h2>

@if (IsComponent)
{
    <a href="@Type.GetTypeDocumentationLink()">
        @Resources["ViewApiReference"]
    </a>
}
else
{
    <h3>
        @Resources["DefinitionHeading"]
    </h3>
    <dl class="flex gap-x-2">
        <dt>
            @Resources["NamespaceLabel"]:
        </dt>
        <dd>
            @Type.Namespace
        </dd>
    </dl>

    if (_typeComments?.Summary != null)
    {
        <p>
            @_typeComments.Summary.ResolveCodeComment()
        </p>
    }

    <pre class="whitespace-normal"><code class="language-csharp">@GetTypeDefinition(Type)</code></pre>

    if (Type.GenericTypeParameters.Any())
    {
        <h4>
            @Resources["TypeParametersHeading"]
        </h4>

        @foreach (var typeParam in Type.GenericTypeParameters)
        {
            <p>
                <code>@typeParam.Name</code>
            </p>
        }
    }

    if (Type.DeclaredConstructors.Any())
    {
        <h4>
            @Resources["ConstructorsHeading"]
        </h4>

        <table>
            <thead>
            <tr>
                <td></td>
                <td></td>
            </tr>
            </thead>
            <tbody>
            @foreach (var ctor in Type.DeclaredConstructors)
            {
                var methodComments = _reader!.GetMethodComments(ctor);
                <tr>
                    <td>
                        <code>@GetConstructorDefinition(ctor)</code>
                    </td>
                    <td>
                        @if (methodComments?.Summary != null)
                        {
                            @methodComments.Summary.ResolveCodeComment()
                        }
                    </td>
                </tr>
            }
            </tbody>
        </table>
    }

    var publicProperties = Type.DeclaredProperties.Where(p => p.GetMethod?.IsPublic == true || p.SetMethod?.IsPublic == true).ToArray();
    if (publicProperties.Any())
    {
        <h4>
            @Resources["PropertiesHeading"]
        </h4>

        <table>
            <thead>
            <tr>
                <td></td>
                <td></td>
            </tr>
            </thead>
            <tbody>
            @foreach (var prop in publicProperties)
            {
                var propComments = _reader!.GetMemberComments(prop);
                <tr>
                    <td>
                        <code>@prop.Name</code>
                    </td>
                    <td>
                        @if (propComments?.Summary != null)
                        {
                            @propComments.Summary.ResolveCodeComment()
                        }
                    </td>
                </tr>
            }
            </tbody>
        </table>
    }

    var publicMethods = Type.DeclaredMethods.Where(m => m is { IsPublic: true,IsSpecialName: false }).ToArray();
    if (publicMethods.Any())
    {
        <h4>
            @Resources["MethodsHeading"]
        </h4>

        <table>
            <thead>
            <tr>
                <td></td>
                <td></td>
            </tr>
            </thead>
            <tbody>
            @foreach (var method in publicMethods)
            {
                var methodComments = _reader!.GetMethodComments(method);
                <tr>
                    <td>
                        <code>@GetMethodDefinition(method)</code>
                    </td>
                    <td>
                        @if (methodComments?.Summary != null)
                        {
                            @methodComments.Summary.ResolveCodeComment()
                        }
                    </td>
                </tr>
            }
            </tbody>
        </table>
    }
}

@code
{
    private DocXmlReader? _reader;
    private TypeComments? _typeComments;

    [Parameter, EditorRequired]
    public TypeInfo Type { get; set; } = null!;

    [Parameter]
    public bool IsComponent { get; set; }

    protected override async Task OnInitializedAsync(CancellationToken cancellationToken)
    {
        var path = $"/_api/{Type.Assembly.GetName().Name}.xml";

        var xml = await StaticFileService.GetFileContentAsXmlAsync(path, cancellationToken);

        _reader = new DocXmlReader(xml);

        _typeComments = _reader.GetTypeComments(Type);
    }

    private string GetTypeDefinition(TypeInfo type)
    {
        var builder = new StringBuilder();
        builder.Append("public");

        if (type is { IsAbstract: true, IsSealed: true }) builder.Append(" static");
        else if (type.IsAbstract) builder.Append(" abstract");
        else if (type.IsSealed) builder.Append(" sealed");

        if (type.IsClass) builder.Append(" class");
        else if (type.IsEnum) builder.Append(" enum");
        else if (type.IsInterface) builder.Append(" interface");
        else if (type.IsValueType) builder.Append(" struct");

        builder.Append(' ');
        builder.Append(type.SanitizeTypeName());

        var types = new List<string>();

        if (type.BaseType != null && type.BaseType != typeof(object))
        {
            types.Add(type.BaseType.GetTypeInfo().SanitizeTypeName(true));
        }

        if (type.ImplementedInterfaces.Any())
        {
            types.AddRange(type.ImplementedInterfaces.Select(i => i.GetTypeInfo().SanitizeTypeName(true)));
        }

        if (types.Any())
        {
            builder.Append(" : ");
            builder.Append(string.Join(", ", types));
        }

        return builder.ToString();
    }

    private string GetConstructorDefinition(ConstructorInfo ctor)
    {
        var definition = new StringBuilder();
        definition.Append(Type.SanitizeTypeName());

        AppendParameters(definition, ctor);

        return definition.ToString();
    }

    private string GetMethodDefinition(MethodInfo method)
    {
        var definition = new StringBuilder();
        definition.Append(method.Name);

        AppendParameters(definition, method);

        return definition.ToString();
    }

    private static void AppendParameters(StringBuilder definition, MethodBase method)
    {
        definition.Append("(");

        var parameter = method.GetParameters();
        foreach (var param in parameter)
        {
            definition.Append(param.ParameterType.GetTypeInfo().SanitizeTypeName());
            definition.Append(" ");
            definition.Append(param.Name);

            if (param.HasDefaultValue)
            {
                definition.Append(" = ");
                definition.Append(param.DefaultValue);
            }
            if (param != parameter.Last())
            {
                definition.Append(", ");
            }
        }

        definition.Append(")");
    }

    public async Task OnAfterRenderAsync()
    {
        await JSRuntime.InvokeVoidAsync("OnPageLoad");
    }
}